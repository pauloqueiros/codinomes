{
  "version": 3,
  "sources": ["../../../../../../node_modules/firebase/app/dist/esm/index.esm.js", "../../../../../../node_modules/@angular/core/fesm2022/rxjs-interop.mjs", "../../../../../../node_modules/@angular/fire/fesm2022/angular-fire.mjs", "../../../../../../node_modules/firebase/compat/app/dist/esm/index.esm.js", "../../../../../../node_modules/@angular/fire/fesm2022/angular-fire-compat.mjs"],
  "sourcesContent": ["import { registerVersion } from '@firebase/app';\nexport * from '@firebase/app';\nvar name = \"firebase\";\nvar version = \"11.4.0\";\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nregisterVersion(name, version, 'app');\n", "/**\n * @license Angular v19.2.0\n * (c) 2010-2024 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, ɵRuntimeError, ɵgetOutputDestroyRef, Injector, effect, untracked, ɵmicrotaskEffect, assertNotInReactiveContext, signal, computed, PendingTasks, resource } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/di/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @publicApi\n */\nfunction takeUntilDestroyed(destroyRef) {\n  if (!destroyRef) {\n    assertInInjectionContext(takeUntilDestroyed);\n    destroyRef = inject(DestroyRef);\n  }\n  const destroyed$ = new Observable(observer => {\n    const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n    return unregisterFn;\n  });\n  return source => {\n    return source.pipe(takeUntil(destroyed$));\n  };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n  source;\n  destroyed = false;\n  destroyRef = inject(DestroyRef);\n  constructor(source) {\n    this.source = source;\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n  subscribe(callbackFn) {\n    if (this.destroyed) {\n      throw new ɵRuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode && 'Unexpected subscription to destroyed `OutputRef`. ' + 'The owning directive/component is destroyed.');\n    }\n    // Stop yielding more values when the directive/component is already destroyed.\n    const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n      next: value => callbackFn(value)\n    });\n    return {\n      unsubscribe: () => subscription.unsubscribe()\n    };\n  }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @publicApi\n */\nfunction outputFromObservable(observable, opts) {\n  ngDevMode && assertInInjectionContext(outputFromObservable);\n  return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @publicApi\n */\nfunction outputToObservable(ref) {\n  const destroyRef = ɵgetOutputDestroyRef(ref);\n  return new Observable(observer => {\n    // Complete the observable upon directive/component destroy.\n    // Note: May be `undefined` if an `EventEmitter` is declared outside\n    // of an injection context.\n    destroyRef?.onDestroy(() => observer.complete());\n    const subscription = ref.subscribe(v => observer.next(v));\n    return () => subscription.unsubscribe();\n  });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = effect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\nfunction toObservableMicrotask(source, options) {\n  !options?.injector && assertInInjectionContext(toObservable);\n  const injector = options?.injector ?? inject(Injector);\n  const subject = new ReplaySubject(1);\n  const watcher = ɵmicrotaskEffect(() => {\n    let value;\n    try {\n      value = source();\n    } catch (err) {\n      untracked(() => subject.error(err));\n      return;\n    }\n    untracked(() => subject.next(value));\n  }, {\n    injector,\n    manualCleanup: true\n  });\n  injector.get(DestroyRef).onDestroy(() => {\n    watcher.destroy();\n    subject.complete();\n  });\n  return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](guide/di/dependency-injection-context) is destroyed. For example, when `toSignal` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nfunction toSignal(source, options) {\n  ngDevMode && assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' + 'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n  const equal = makeToSignalEqual(options?.equal);\n  // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n  // the same - the returned signal gives values of type `T`.\n  let state;\n  if (options?.requireSync) {\n    // Initially the signal is in a `NoValue` state.\n    state = signal({\n      kind: 0 /* StateKind.NoValue */\n    }, {\n      equal\n    });\n  } else {\n    // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n    state = signal({\n      kind: 1 /* StateKind.Value */,\n      value: options?.initialValue\n    }, {\n      equal\n    });\n  }\n  // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n  // this, we would subscribe to the observable outside of the current reactive context, avoiding\n  // that side-effect signal reads/writes are attribute to the current consumer. The current\n  // consumer only needs to be notified when the `state` signal changes through the observable\n  // subscription. Additional context (related to async pipe):\n  // https://github.com/angular/angular/pull/50522.\n  const sub = source.subscribe({\n    next: value => state.set({\n      kind: 1 /* StateKind.Value */,\n      value\n    }),\n    error: error => {\n      if (options?.rejectErrors) {\n        // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n        // the error to end up as an uncaught exception.\n        throw error;\n      }\n      state.set({\n        kind: 2 /* StateKind.Error */,\n        error\n      });\n    }\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n  if (options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n    throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n  }\n  // Unsubscribe when the current context is destroyed, if requested.\n  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n  // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n  // to either values or errors.\n  return computed(() => {\n    const current = state();\n    switch (current.kind) {\n      case 1 /* StateKind.Value */:\n        return current.value;\n      case 2 /* StateKind.Error */:\n        throw current.error;\n      case 0 /* StateKind.NoValue */:\n        // This shouldn't really happen because the error is thrown on creation.\n        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, (typeof ngDevMode === 'undefined' || ngDevMode) && '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n  }, {\n    equal: options?.equal\n  });\n}\nfunction makeToSignalEqual(userEquality = Object.is) {\n  return (a, b) => a.kind === 1 /* StateKind.Value */ && b.kind === 1 /* StateKind.Value */ && userEquality(a.value, b.value);\n}\n\n/**\n * Operator which makes the application unstable until the observable emits, complets, errors, or is unsubscribed.\n *\n * Use this operator in observables whose subscriptions are important for rendering and should be included in SSR serialization.\n *\n * @param injector The `Injector` to use during creation. If this is not provided, the current injection context will be used instead (via `inject`).\n *\n * @experimental\n */\nfunction pendingUntilEvent(injector) {\n  if (injector === undefined) {\n    assertInInjectionContext(pendingUntilEvent);\n    injector = inject(Injector);\n  }\n  const taskService = injector.get(PendingTasks);\n  return sourceObservable => {\n    return new Observable(originalSubscriber => {\n      // create a new task on subscription\n      const removeTask = taskService.add();\n      let cleanedUp = false;\n      function cleanupTask() {\n        if (cleanedUp) {\n          return;\n        }\n        removeTask();\n        cleanedUp = true;\n      }\n      const innerSubscription = sourceObservable.subscribe({\n        next: v => {\n          originalSubscriber.next(v);\n          cleanupTask();\n        },\n        complete: () => {\n          originalSubscriber.complete();\n          cleanupTask();\n        },\n        error: e => {\n          originalSubscriber.error(e);\n          cleanupTask();\n        }\n      });\n      innerSubscription.add(() => {\n        originalSubscriber.unsubscribe();\n        cleanupTask();\n      });\n      return innerSubscription;\n    });\n  };\n}\nfunction rxResource(opts) {\n  opts?.injector || assertInInjectionContext(rxResource);\n  return resource({\n    ...opts,\n    loader: undefined,\n    stream: params => {\n      let sub;\n      // Track the abort listener so it can be removed if the Observable completes (as a memory\n      // optimization).\n      const onAbort = () => sub.unsubscribe();\n      params.abortSignal.addEventListener('abort', onAbort);\n      // Start off stream as undefined.\n      const stream = signal({\n        value: undefined\n      });\n      let resolve;\n      const promise = new Promise(r => resolve = r);\n      function send(value) {\n        stream.set(value);\n        resolve?.(stream);\n        resolve = undefined;\n      }\n      sub = opts.loader(params).subscribe({\n        next: value => send({\n          value\n        }),\n        error: error => send({\n          error\n        }),\n        complete: () => {\n          if (resolve) {\n            send({\n              error: new Error('Resource completed before producing a value')\n            });\n          }\n          params.abortSignal.removeEventListener('abort', onAbort);\n        }\n      });\n      return promise;\n    }\n  });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { outputFromObservable, outputToObservable, pendingUntilEvent, rxResource, takeUntilDestroyed, toObservable, toSignal, toObservableMicrotask as ɵtoObservableMicrotask };\n", "import * as i0 from '@angular/core';\nimport { Version, isDevMode, inject, NgZone, Injectable, runInInjectionContext, PendingTasks, EnvironmentInjector } from '@angular/core';\nimport { getApps } from 'firebase/app';\nimport { pendingUntilEvent } from '@angular/core/rxjs-interop';\nimport { queueScheduler, asyncScheduler, Observable } from 'rxjs';\nimport { subscribeOn, observeOn } from 'rxjs/operators';\nconst VERSION = new Version('ANGULARFIRE2_VERSION');\nconst ɵisSupportedError = module => `The APP_INITIALIZER that is \"making\" isSupported() sync for the sake of convenient DI has not resolved in this\ncontext. Rather than injecting ${module} in the constructor, first ensure that ${module} is supported by calling\n\\`await isSupported()\\`, then retrieve the instance from the injector manually \\`injector.get(${module})\\`.`;\nfunction ɵgetDefaultInstanceOf(identifier, provided, defaultApp) {\n  if (provided) {\n    // Was provide* only called once? If so grab that\n    if (provided.length === 1) {\n      return provided[0];\n    }\n    const providedUsingDefaultApp = provided.filter(it => it.app === defaultApp);\n    // Was provide* only called once, using the default app? If so use that\n    if (providedUsingDefaultApp.length === 1) {\n      return providedUsingDefaultApp[0];\n    }\n  }\n  // Grab the default instance from the defaultApp\n  const defaultAppWithContainer = defaultApp;\n  const provider = defaultAppWithContainer.container.getProvider(identifier);\n  return provider.getImmediate({\n    optional: true\n  });\n}\nconst ɵgetAllInstancesOf = (identifier, app) => {\n  const apps = app ? [app] : getApps();\n  const instances = [];\n  apps.forEach(app => {\n    const provider = app.container.getProvider(identifier);\n    provider.instances.forEach(instance => {\n      if (!instances.includes(instance)) {\n        instances.push(instance);\n      }\n    });\n  });\n  return instances;\n};\n\n/* eslint-disable @typescript-eslint/ban-ts-comment */\nvar LogLevel;\n(function (LogLevel) {\n  LogLevel[LogLevel[\"SILENT\"] = 0] = \"SILENT\";\n  LogLevel[LogLevel[\"WARN\"] = 1] = \"WARN\";\n  LogLevel[LogLevel[\"VERBOSE\"] = 2] = \"VERBOSE\";\n})(LogLevel || (LogLevel = {}));\nvar currentLogLevel = isDevMode() && typeof Zone !== \"undefined\" ? LogLevel.WARN : LogLevel.SILENT;\nconst setLogLevel = logLevel => currentLogLevel = logLevel;\n/**\n * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.\n */\nclass ɵZoneScheduler {\n  zone;\n  delegate;\n  constructor(zone, delegate = queueScheduler) {\n    this.zone = zone;\n    this.delegate = delegate;\n  }\n  now() {\n    return this.delegate.now();\n  }\n  schedule(work, delay, state) {\n    const targetZone = this.zone;\n    // Wrap the specified work function to make sure that if nested scheduling takes place the\n    // work is executed in the correct zone\n    const workInZone = function (state) {\n      if (targetZone) {\n        targetZone.runGuarded(() => {\n          work.apply(this, [state]);\n        });\n      } else {\n        work.apply(this, [state]);\n      }\n    };\n    // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done\n    // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that\n    // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.\n    return this.delegate.schedule(workInZone, delay, state);\n  }\n}\nclass ɵAngularFireSchedulers {\n  outsideAngular;\n  insideAngular;\n  constructor() {\n    const ngZone = inject(NgZone);\n    this.outsideAngular = ngZone.runOutsideAngular(() => new ɵZoneScheduler(typeof Zone === 'undefined' ? undefined : Zone.current));\n    this.insideAngular = ngZone.run(() => new ɵZoneScheduler(typeof Zone === 'undefined' ? undefined : Zone.current, asyncScheduler));\n  }\n  static ɵfac = function ɵAngularFireSchedulers_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || ɵAngularFireSchedulers)();\n  };\n  static ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ɵAngularFireSchedulers,\n    factory: ɵAngularFireSchedulers.ɵfac,\n    providedIn: 'root'\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ɵAngularFireSchedulers, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [], null);\n})();\nvar alreadyWarned = false;\nfunction warnOutsideInjectionContext(original, logLevel) {\n  if (!alreadyWarned && (currentLogLevel > LogLevel.SILENT || isDevMode())) {\n    alreadyWarned = true;\n    console.warn(\"Calling Firebase APIs outside of an Injection context may destabilize your application leading to subtle change-detection and hydration bugs. Find more at https://github.com/angular/angularfire/blob/main/docs/zones.md\");\n  }\n  if (currentLogLevel >= logLevel) {\n    console.warn(`Firebase API called outside injection context: ${original.name}`);\n  }\n}\nfunction runOutsideAngular(fn) {\n  const ngZone = inject(NgZone, {\n    optional: true\n  });\n  if (!ngZone) {\n    return fn();\n  }\n  return ngZone.runOutsideAngular(() => fn());\n}\nfunction run(fn) {\n  const ngZone = inject(NgZone, {\n    optional: true\n  });\n  if (!ngZone) {\n    return fn();\n  }\n  return ngZone.run(() => fn());\n}\nconst zoneWrapFn = (it, taskDone, injector) => {\n  return (...args) => {\n    if (taskDone) {\n      setTimeout(taskDone, 0);\n    }\n    return runInInjectionContext(injector, () => run(() => it.apply(this, args)));\n  };\n};\nconst ɵzoneWrap = (it, blockUntilFirst, logLevel) => {\n  logLevel ||= blockUntilFirst ? LogLevel.WARN : LogLevel.VERBOSE;\n  // function() is needed for the arguments object\n  return function () {\n    let taskDone;\n    const _arguments = arguments;\n    let schedulers;\n    let pendingTasks;\n    let injector;\n    try {\n      schedulers = inject(ɵAngularFireSchedulers);\n      pendingTasks = inject(PendingTasks);\n      injector = inject(EnvironmentInjector);\n    } catch (e) {\n      warnOutsideInjectionContext(it, logLevel);\n      return it.apply(this, _arguments);\n    }\n    // if this is a callback function, e.g, onSnapshot, we should create a pending task and complete it\n    // only once one of the callback functions is tripped.\n    for (let i = 0; i < arguments.length; i++) {\n      if (typeof _arguments[i] === 'function') {\n        if (blockUntilFirst) {\n          taskDone ||= run(() => pendingTasks.add());\n        }\n        // TODO create a microtask to track callback functions\n        _arguments[i] = zoneWrapFn(_arguments[i], taskDone, injector);\n      }\n    }\n    const ret = runOutsideAngular(() => it.apply(this, _arguments));\n    if (!blockUntilFirst) {\n      if (ret instanceof Observable) {\n        return ret.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular));\n      } else {\n        return run(() => ret);\n      }\n    }\n    if (ret instanceof Observable) {\n      return ret.pipe(subscribeOn(schedulers.outsideAngular), observeOn(schedulers.insideAngular), pendingUntilEvent(injector));\n    } else if (ret instanceof Promise) {\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      return run(() => new Promise((resolve, reject) => {\n        pendingTasks.run(() => ret).then(it => runInInjectionContext(injector, () => run(() => resolve(it))), reason => runInInjectionContext(injector, () => run(() => reject(reason))));\n      }));\n    } else if (typeof ret === 'function' && taskDone) {\n      // Handle unsubscribe\n      // function() is needed for the arguments object\n      return function () {\n        setTimeout(taskDone, 0);\n        return ret.apply(this, arguments);\n      };\n    } else {\n      // TODO how do we handle storage uploads in Zone? and other stuff with cancel() etc?\n      return run(() => ret);\n    }\n  };\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LogLevel, VERSION, setLogLevel, ɵAngularFireSchedulers, ɵZoneScheduler, ɵgetAllInstancesOf, ɵgetDefaultInstanceOf, ɵisSupportedError, ɵzoneWrap };\n", "import firebase from '@firebase/app-compat';\nexport { default } from '@firebase/app-compat';\nvar name = \"firebase\";\nvar version = \"11.4.0\";\n\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfirebase.registerVersion(name, version, 'app-compat');\n", "import * as i0 from '@angular/core';\nimport { InjectionToken, isDevMode, NgZone, Optional, VERSION as VERSION$1, PLATFORM_ID, NgModule, Inject } from '@angular/core';\nimport { VERSION } from '@angular/fire';\nimport firebase from 'firebase/compat/app';\n\n// DEBUG quick debugger function for inline logging that typescript doesn't complain about\n//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a\n//       verbose mode for AngularFire in a future release that uses something like this in multiple places\n//       usage: () => log('something') || returnValue\n// const log = (...args: any[]): false => { console.log(...args); return false }\n// The problem here are things like ngOnDestroy are missing, then triggering the service\n// rather than dig too far; I'm capturing these as I go.\nconst noopFunctions = ['ngOnDestroy'];\n// INVESTIGATE should we make the Proxy revokable and do some cleanup?\n//             right now it's fairly simple but I'm sure this will grow in complexity\nconst ɵlazySDKProxy = (klass, observable, zone, options = {}) => {\n  return new Proxy(klass, {\n    get: (_, name) => zone.runOutsideAngular(() => {\n      if (klass[name]) {\n        if (options?.spy?.get) {\n          options.spy.get(name, klass[name]);\n        }\n        return klass[name];\n      }\n      if (noopFunctions.indexOf(name) > -1) {\n        return () => undefined;\n      }\n      const promise = observable.toPromise().then(mod => {\n        const ret = mod?.[name];\n        // TODO move to proper type guards\n        if (typeof ret === 'function') {\n          return ret.bind(mod);\n        } else if (ret?.then) {\n          return ret.then(res => zone.run(() => res));\n        } else {\n          return zone.run(() => ret);\n        }\n      });\n      // recurse the proxy\n      return new Proxy(() => undefined, {\n        get: (_, name) => promise[name],\n        // TODO handle callbacks as transparently as I can\n        apply: (self, _, args) => promise.then(it => {\n          const res = it?.(...args);\n          if (options?.spy?.apply) {\n            options.spy.apply(name, args, res);\n          }\n          return res;\n        })\n      });\n    })\n  });\n};\nconst ɵapplyMixins = (derivedCtor, constructors) => {\n  constructors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype || baseCtor).forEach(name => {\n      Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype || baseCtor, name));\n    });\n  });\n};\nclass FirebaseApp {\n  constructor(app) {\n    return app;\n  }\n}\nconst FIREBASE_OPTIONS = new InjectionToken('angularfire2.app.options');\nconst FIREBASE_APP_NAME = new InjectionToken('angularfire2.app.name');\nfunction ɵfirebaseAppFactory(options, zone, nameOrConfig) {\n  const name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';\n  const config = typeof nameOrConfig === 'object' && nameOrConfig || {};\n  config.name = config.name || name;\n  // Added any due to some inconsistency between @firebase/app and firebase types\n  const existingApp = firebase.apps.filter(app => app && app.name === config.name)[0];\n  // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any\n  // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206\n  const app = existingApp || zone.runOutsideAngular(() => firebase.initializeApp(options, config));\n  try {\n    if (JSON.stringify(options) !== JSON.stringify(app.options)) {\n      const hmr = !!module.hot;\n      log$1('error', `${app.name} Firebase App already initialized with different options${hmr ? ', you may need to reload as Firebase is not HMR aware.' : '.'}`);\n    }\n  } catch (e) {/* empty */}\n  return new FirebaseApp(app);\n}\nconst log$1 = (level, ...args) => {\n  if (isDevMode() && typeof console !== 'undefined') {\n    // eslint-disable-next-line no-console\n    console[level](...args);\n  }\n};\nconst FIREBASE_APP_PROVIDER = {\n  provide: FirebaseApp,\n  useFactory: ɵfirebaseAppFactory,\n  deps: [FIREBASE_OPTIONS, NgZone, [new Optional(), FIREBASE_APP_NAME]]\n};\nclass AngularFireModule {\n  static initializeApp(options, nameOrConfig) {\n    return {\n      ngModule: AngularFireModule,\n      providers: [{\n        provide: FIREBASE_OPTIONS,\n        useValue: options\n      }, {\n        provide: FIREBASE_APP_NAME,\n        useValue: nameOrConfig\n      }]\n    };\n  }\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  constructor(platformId) {\n    firebase.registerVersion('angularfire', VERSION.full, 'core');\n    firebase.registerVersion('angularfire', VERSION.full, 'app-compat');\n    // eslint-disable-next-line @typescript-eslint/no-base-to-string\n    firebase.registerVersion('angular', VERSION$1.full, platformId.toString());\n  }\n  static ɵfac = function AngularFireModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || AngularFireModule)(i0.ɵɵinject(PLATFORM_ID));\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AngularFireModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [FIREBASE_APP_PROVIDER]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AngularFireModule, [{\n    type: NgModule,\n    args: [{\n      providers: [FIREBASE_APP_PROVIDER]\n    }]\n  }], () => [{\n    type: Object,\n    decorators: [{\n      type: Inject,\n      args: [PLATFORM_ID]\n    }]\n  }], null);\n})();\nfunction ɵcacheInstance(cacheKey, moduleName, appName, fn, deps) {\n  const [, instance, cachedDeps] = globalThis.ɵAngularfireInstanceCache.find(it => it[0] === cacheKey) || [];\n  if (instance) {\n    if (!matchDep(deps, cachedDeps)) {\n      log('error', `${moduleName} was already initialized on the ${appName} Firebase App with different settings.${IS_HMR ? ' You may need to reload as Firebase is not HMR aware.' : ''}`);\n      log('warn', {\n        is: deps,\n        was: cachedDeps\n      });\n    }\n    return instance;\n  } else {\n    const newInstance = fn();\n    globalThis.ɵAngularfireInstanceCache.push([cacheKey, newInstance, deps]);\n    return newInstance;\n  }\n}\nfunction matchDep(a, b) {\n  try {\n    return a.toString() === b.toString();\n  } catch (_) {\n    return a === b;\n  }\n}\nconst IS_HMR = typeof module !== 'undefined' && !!module.hot;\nconst log = (level, ...args) => {\n  if (isDevMode() && typeof console !== 'undefined') {\n    // eslint-disable-next-line no-console\n    console[level](...args);\n  }\n};\nglobalThis.ɵAngularfireInstanceCache ||= [];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AngularFireModule, FIREBASE_APP_NAME, FIREBASE_OPTIONS, FirebaseApp, ɵapplyMixins, ɵcacheInstance, ɵfirebaseAppFactory, ɵlazySDKProxy };\n"],
  "mappings": "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",
  "names": ["VERSION", "app", "LogLevel", "state", "it", "name", "version", "name", "_", "app", "VERSION"]
}
